package com.betamedia.atom.core.dsl.operations.impl;

import com.betamedia.atom.core.connectors.tp.FWTPConnector;
import com.betamedia.atom.core.dsl.operations.SchedulerOperations;
import com.betamedia.atom.core.dsl.operations.TagOperations;
import com.betamedia.atom.core.environment.tp.EnvironmentDependent;
import com.betamedia.common.search.criteria.SearchCriteria;
import com.betamedia.common.utils.Time;
import com.betamedia.tp.api.model.enums.OptionSubType;
import com.betamedia.tp.api.model.scheduling.OptionTemplateScheduler;
import com.betamedia.tp.api.model.scheduling.RecurringSchedulingUnit;
import com.google.common.collect.Range;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.Collections;
import java.util.List;
import java.util.TreeSet;
import java.util.stream.IntStream;

/**
 * Created by mbelyaev on 3/24/17.
 */
public abstract class AbstractSchedulerOperations<T extends EnvironmentDependent> implements SchedulerOperations<T> {
    private static final Logger logger = LogManager.getLogger(AbstractSchedulerOperations.class);

    @Autowired
    private FWTPConnector<T> tpConnector;

    @Override
    public List<OptionTemplateScheduler> get(String timezoneId, TagOperations.TagName tagName) {
        return tpConnector.readMultiple(forTimezoneSubtype(timezoneId, TagOperations.getOptionSubtype(tagName)), null, null).getContent();
    }

    @Override
    public OptionTemplateScheduler create(String timezoneId, TagOperations.TagName tagName) {
        OptionTemplateScheduler optionTemplateScheduler = new OptionTemplateScheduler();
        optionTemplateScheduler.setDescription("This scheduler was created by automatic test");
        optionTemplateScheduler.setIsIssuedBySystem(TagOperations.getOptionSubtype(tagName).equals(OptionSubType.NONE));
        optionTemplateScheduler.setName("autogenerated");
        optionTemplateScheduler.setSchedules(Collections.singletonList(getSchedulingUnit(tagName)));
        optionTemplateScheduler.setTimezoneId(timezoneId);
        optionTemplateScheduler = tpConnector.create(optionTemplateScheduler);
        logger.info("Scheduler '" + optionTemplateScheduler.getDisplayId() + "' created");
        return optionTemplateScheduler;
    }

    private RecurringSchedulingUnit getSchedulingUnit(TagOperations.TagName tagName){
        RecurringSchedulingUnit schedulingUnit = new RecurringSchedulingUnit();
        schedulingUnit.setDays(new Boolean[]{true, true, true, true, true, true, true, true});
        schedulingUnit.setHours(Collections.singletonList(Range.closed(new Time(0, 0), new Time(23, 59))));
        TreeSet<Integer> minutes = new TreeSet<>();
        IntStream.range(0, 60).forEach(minutes::add);
        schedulingUnit.setMinutes(minutes);
        schedulingUnit.setDuration(0, 0, 0, TagOperations.getDuration(tagName));
        return schedulingUnit;
    }

    private SearchCriteria<OptionTemplateScheduler> forTimezoneSubtype(String timezoneId, OptionSubType subType) {
        return new SearchCriteria<>(OptionTemplateScheduler.class)
                .and(OptionTemplateScheduler.EP_TIMEZONE_ID.equalsTo(timezoneId))
                .and(subType.equals(OptionSubType.NONE) ?
                        OptionTemplateScheduler.EP_IS_ISSUED_BY_SYSTEM.isTrue() :
                        OptionTemplateScheduler.EP_IS_ISSUED_BY_SYSTEM.isFalse()
                );
    }
}
