package com.betamedia.qe.af.core.api.tp.operations.impl;

import com.betamedia.common.search.criteria.SearchCriteria;
import com.betamedia.common.utils.DateUtils;
import com.betamedia.common.utils.Time;
import com.betamedia.qe.af.common.connectors.tp.AFTPConnector;
import com.betamedia.qe.af.core.api.tp.operations.SchedulerOperations;
import com.betamedia.qe.af.core.api.tp.operations.TagOperations;
import com.betamedia.qe.af.core.api.tp.operations.TimezoneOperations;
import com.betamedia.tp.api.model.enums.OptionSubType;
import com.betamedia.tp.api.model.scheduling.OptionTemplateScheduler;
import com.betamedia.tp.api.model.scheduling.RecurringSchedulingUnit;
import com.google.common.collect.Range;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.*;

/**
 * Created by mbelyaev on 3/24/17.
 */
@Component
public class SchedulerOperationsImpl implements SchedulerOperations {
    private static final Logger logger = LogManager.getLogger(SchedulerOperationsImpl.class);

    @Autowired
    private AFTPConnector tpConnector;

    @Override
    public List<OptionTemplateScheduler> get(String timezoneId, TagOperations.TagName tagName) {
        return tpConnector.readMultiple(forTimezoneSubtype(timezoneId, TagOperations.getOptionSubtype(tagName)), null, null).getContent();
    }

    //todo refactor
    @Override
    public OptionTemplateScheduler create(String timezoneId, TagOperations.TagName tagName) {
        OptionTemplateScheduler optionTemplateScheduler = new OptionTemplateScheduler();
        optionTemplateScheduler.setDescription("This scheduler was created by automatic test");
        optionTemplateScheduler.setIsIssuedBySystem(TagOperations.getOptionSubtype(tagName).equals(OptionSubType.NONE));
        optionTemplateScheduler.setName("autogenerated");
        List<RecurringSchedulingUnit> schedules = new ArrayList<>();
        RecurringSchedulingUnit recurringSchedulingUnit = new RecurringSchedulingUnit();
        Boolean[] days = new Boolean[8];
        days[7] = true;
        recurringSchedulingUnit.setDays(days);
        int optionDuration = TagOperations.getDuration(tagName);
        recurringSchedulingUnit.setDuration(0, 0, 0, optionDuration);
        List<Range<Time>> list = new ArrayList<>();
        list.add(Range.closed(new Time(23, 58), new Time(23, 59)));
        recurringSchedulingUnit.setHours(list);
        TreeSet<Integer> minutes = new TreeSet<>();
        if (DateUtils.getCurrentMinute() >= 58 && DateUtils.getCurrentHour() < 23) {
            minutes.add(DateUtils.getCurrentMinute() - 1);
        } else if (DateUtils.getCurrentMinute() >= 58 && DateUtils.getCurrentHour() == 23) {
            days[DateUtils.getDayOfWeek(DateUtils.plusDays(new Date(), 1))] = true;
            recurringSchedulingUnit.setDays(days);
            minutes.add(DateUtils.getCurrentMinute() - 1);
        } else {
            minutes.add(DateUtils.getCurrentMinute() + 2);
        }
        recurringSchedulingUnit.setMinutes(minutes);
        schedules.add(recurringSchedulingUnit);
        optionTemplateScheduler.setSchedules(schedules);
        optionTemplateScheduler.setTimezoneId(timezoneId);
        optionTemplateScheduler = tpConnector.create(optionTemplateScheduler);
        logger.info("Scheduler '" + optionTemplateScheduler.getDisplayId() + "' created");
        return optionTemplateScheduler;
    }

    private SearchCriteria<OptionTemplateScheduler> forTimezoneSubtype(String timezoneId, OptionSubType subType) {
        return new SearchCriteria<>(OptionTemplateScheduler.class)
                .and(OptionTemplateScheduler.EP_TIMEZONE_ID.equalsTo(timezoneId))
                .and(subType.equals(OptionSubType.NONE) ?
                        OptionTemplateScheduler.EP_IS_ISSUED_BY_SYSTEM.isTrue() :
                        OptionTemplateScheduler.EP_IS_ISSUED_BY_SYSTEM.isFalse()
                );
    }
}
